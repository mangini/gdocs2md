/*
Usage: 
  Add this script to a document (doesn't need to be the one you wish to export): 
    - Tools > Script Editor > New
    - Select "Blank Project", then paste this code in and save.
    
  Preparing files:
    - Put all documents you wish to convert into category folders within a folder in your docs list,
      called "DocsToConvertToMarkdown". Each category folder can contain multiple documents. You can
      use just one category folder, e.g. "default" if you don't want to use categories.
  
  Running the script:
    - Tools > Script Manager
    - Select "convertDefaultFolder()" function.
    - Click Run button.
    - All documents in the folder will be converted to markdown,
      and resulting files put in a new subfolder called "ExportedMarkdown-TIMESTAMP"
      where TIMESTAMP is the current ISO GMT timestamp.
          
  Settings:
    There are several optional features, convertDefaultFolder() runs with most features enabled,
    however most other functions take a settings object. The following fields should be set to true
    to enable the corresponding features:
      
    - markdownTables - Output tables in GitHub-Flavoured Markdown rather than HTML. This also supports
      bold and italic formatting, and inline code blocks, within table cells.
      
    - plainTextOutput - Output markdown to plaintext files (type "text/plain" with .txt extension), 
      allowing for viewing directly in Google Docs. If this is not specified, files will be have
      type "text/x-markdown" and .md extension.
      
    - boldItalicIsQuote - Any lines starting with bold+italic formatting will become block quotes
      in the markdown output.
      
    - codeBlocks - Any lines starting with a tab and then containing at least one courier-new formatted
      character will be considered as code lines. In addition, any empty or whitespace-only lines
      following a code line will be considered to be code lines. Runs of code lines will be output with three
      backticks before and after the run, and with the first tab (if any) removed from each line, to form a 
      standard markdown code block.
  
  Using different folders:
    - You can call convertFolderByName(folderName, settings) with a different folder name as required

*/

function convertDefaultFolder() {
  var settings = {markdownTables: true, plainTextOutput: false, boldItalicIsQuote: true, codeBlocks: true, codeBlockMinIndent: 12};
  convertDefaultFolderWithSettings(settings);
}

function convertDefaultFolderWithSettings(settings) {
  convertDownOneLevelByName('DocsToConvertToMarkdown', settings);
}

function convertDownOneLevelByName(folderName, settings) {
  var folder = DocsList.getFolder(folderName);
  convertDownOneLevel(folder, settings);  
}

function convertDownOneLevel(rootFolder, settings) {
  var mainExportFolder = rootFolder.createFolder(exportFolderName())
  var folders = rootFolder.getFolders();
  //Convert all folders that don't start with our export prefix
  for (var i in folders) {
    var folder = folders[i];
    if (folder.getName().substring(0, exportFolderPrefix.length) != exportFolderPrefix) {
      var exportFolder = mainExportFolder.createFolder(folder.getName())
      convertFolder(folder, exportFolder, settings);
    }
  }
  //Convert contents of the folder as well, mainly to catch any meta data
  convertFolder(rootFolder, mainExportFolder, settings);
}

function convertFolderByName(folderName, settings) {
  var folder = DocsList.getFolder(folderName);
  var exportFolder = folder.createFolder(exportFolderName())
  convertFolder(folder, exportFolder, settings);
}

function convertFolder(folder, exportFolder, settings) {
  var files = folder.getFilesByType(DocsList.FileType.DOCUMENT);

  var convertedDocNames = "";
  
  for (var i in files) {
    var doc = DocumentApp.openById(files[i].getId());
    var converted = convertToMarkdownAttachments(doc, settings);
    var docFolder = exportFolder.createFolder(doc.getName());
    convertedDocNames += doc.getName() + "\n";

    // Write all files to target folder
    for(var file in converted.files) {
      file = converted.files[file];
      var blob = file.blob.copyBlob();
      var name = file.name; 
      blob.setName(name); 
      docFolder.createFile(blob); 
    }
    
    // Write markdown file to target folder
    if (settings.plainTextOutput) {
      docFolder.createFile(doc.getName() + ".txt", converted.markdown, "text/plain");  
    } else {
      docFolder.createFile(doc.getName() + ".md", converted.markdown, "text/x-markdown");  
    }
  }
  
  //FIXME display some other way? Browser only works from a spreadsheet!
  //Browser.msgBox("Export complete", "Converted documents:\n" + convertedDocNames, Browser.Buttons.OK)
}

var exportFolderPrefix = "ExportedMarkdown-";

function exportFolderName() {
  var timeStamp = Utilities.formatDate(new Date(), "GMT", "yyyy-MM-dd'T'HH:mm:ss'Z'");
  return exportFolderPrefix + timeStamp;
}

function mailActiveDocumentAsMarkdown() {
  var doc = DocumentApp.getActiveDocument();
  var attachments = convertToMarkdownAttachments(doc).attachments;
  mailWithAttachments(doc, attachments);
}

function mailWithAttachments(document, attachments) {
  MailApp.sendEmail(
    Session.getActiveUser().getEmail(), 
    "[MARKDOWN_MAKER] "+document.getName(), 
    "Your converted markdown document is attached (converted from " + document.getUrl() + ")" +
    "\n\nDon't know how to use the format options? See http://github.com/mangini/gdocs2md\n",
    { "attachments": attachments });
}

function convertToMarkdownAttachments(document, settings) {
  var numChildren = document.getActiveSection().getNumChildren();
  var text = "";
  var inSrc = false;
  var inCodeBlock = false;
  var inClass = false;
  var globalImageCounter = 0;
  var globalListCounters = {};
  // edbacher: added a variable for indent in src <pre> block. Let style sheet do margin.
  var srcIndent = "";
  
  var attachments = [];
  var files = [];
  
  // Walk through all the child elements of the doc.
  for (var i = 0; i < numChildren; i++) {
    var child = document.getActiveSection().getChild(i);
    var result = processParagraph(i, child, inSrc, globalImageCounter, globalListCounters, settings, inCodeBlock);
    globalImageCounter += (result && result.images) ? result.images.length : 0;
    if (result!==null) {
      
      if (inCodeBlock && !result.cbl) {
        text+="```\n\n";
        inCodeBlock = false;
      }
      
      if (result.cbl) {
        if (!inCodeBlock) {
          text+="\n```\n";
          inCodeBlock = true;
        }
        text+=result.text + "\n";
        
      } else if (result.sourcePretty==="start" && !inSrc) {
        inSrc=true;
        text+="<pre class=\"prettyprint\">\n";
      } else if (result.sourcePretty==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.source==="start" && !inSrc) {
        inSrc=true;
        text+="<pre>\n";
      } else if (result.source==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.inClass==="start" && !inClass) {
        inClass=true;
        text+="<div class=\""+result.className+"\">\n";
      } else if (result.inClass==="end" && inClass) {
        inClass=false;
        text+="</div>\n\n";
      } else if (inClass) {
        text+=result.text+"\n\n";
      } else if (inSrc) {
        text+=(srcIndent+escapeHTML(result.text)+"\n");
      } else if (result.text && result.text.length>0) {
        text+=result.text+"\n\n";
      }
      
      if (result.images && result.images.length>0) {
        for (var j=0; j<result.images.length; j++) {
          attachments.push( {
            "fileName": result.images[j].name,
            "mimeType": result.images[j].type,
            "content": result.images[j].bytes } );
          
          files.push( {
            "name" : result.images[j].name,
            "blob" : result.images[j].blob
          });

        }
      }
    } else if (inSrc) { // support empty lines inside source code
      text+='\n';
    }
      
  }
  
  if (settings.plainTextOutput) {
    attachments.push({"fileName":document.getName()+".txt", "mimeType": "text/plain", "content": text});
  } else {
    attachments.push({"fileName":document.getName()+".md", "mimeType": "text/x-markdown", "content": text});
  }

  return {attachments: attachments, files: files, markdown: text};
}

function escapeHTML(text) {
  return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

// Process each child element (not just paragraphs).
function processParagraph(index, element, inSrc, imageCounter, listCounters, settings, inCodeBlock) {

  // Set up for real results.
  var result = {};
  var pOut = "";
  var textElements = [];
  var imagePrefix = "image_";
  var indented = false;
    
  // First, check for things that require no processing.
  if (element.getNumChildren()==0) {
    if (inCodeBlock) {
      result.text = "";
      result.cbl = true;
      return result;
    } else {
      return null;
    }
  }  
  
  // Punt on TOC.
  if (element.getType() === DocumentApp.ElementType.TABLE_OF_CONTENTS) {
    return {"text": "[[TOC]]"};
  }
  
  //Check for indent that can indicate code block etc.
  if (element.getType() === DocumentApp.ElementType.PARAGRAPH) {
    if (isNumber(settings.codeBlockMinIndent)) {
      if (element.getIndentStart() > settings.codeBlockMinIndent) {
        indented = true;
      }
    }
  }
  
  // Handle Table elements. Pretty simple-minded now, but works for simple tables.
  // Note that Markdown does not process within block-level HTML, so it probably 
  // doesn't make sense to add markup within tables.
  if (element.getType() === DocumentApp.ElementType.TABLE) {
    
    //Markdown table
    if (settings.markdownTables) {
      textElements.push("\n");
      var nCols = element.getChild(0).getNumCells();
      for (var i = 0; i < element.getNumChildren(); i++) {
        // process this row
        for (var j = 0; j < nCols; j++) {
          var cell = element.getChild(i).getChild(j);
          
          //We expect the TableCell to have a single Paragraph child - if
          //so we will add all its text elements to our textElements array for
          //later processing
          if (cell.getNumChildren() > 0) {
            var cellPara = cell.getChild(0);
            if (cellPara.getType() === DocumentApp.ElementType.PARAGRAPH) {
              for (var k = 0; k < cellPara.getNumChildren(); k++) {
                var el = cellPara.getChild(k);
                if (el.getType() === DocumentApp.ElementType.TEXT) {
                  textElements.push(el);
                }
              }
            }
          }
            
          if (j < nCols - 1) textElements.push(" | ");
        }
        textElements.push("\n");
        
        //Line of row separators after first row (assumed to be table headings)
        if (i == 0) {
          for (var j = 0; j < nCols; j++) {
            textElements.push("---");
            if (j < nCols - 1) textElements.push(" | ");
          }
          textElements.push("\n");
        }
      }      
      textElements.push("\n");
      
    //HTML table
    } else {
      textElements.push("<table>\n");
      var nCols = element.getChild(0).getNumCells();
      for (var i = 0; i < element.getNumChildren(); i++) {
        textElements.push("  <tr>\n");
        // process this row
        for (var j = 0; j < nCols; j++) {
          textElements.push("    <td>" + element.getChild(i).getChild(j).getText() + "</td>\n");
        }
        textElements.push("  </tr>\n");
      }
      textElements.push("</table>\n");
    }
  }
  
  // Process various types (ElementType).
  for (var i = 0; i < element.getNumChildren(); i++) {
    var t=element.getChild(i).getType();
    
    if (t === DocumentApp.ElementType.TABLE_ROW) {
      // do nothing: already handled TABLE_ROW
    } else if (t === DocumentApp.ElementType.TEXT) {
      var txt=element.getChild(i);
      pOut += txt.getText();
      textElements.push(txt);
    } else if (t === DocumentApp.ElementType.INLINE_IMAGE) {
      result.images = result.images || [];
      var contentType = element.getChild(i).getBlob().getContentType();
      var extension = "";
      if (/\/png$/.test(contentType)) {
        extension = ".png";
      } else if (/\/gif$/.test(contentType)) {
        extension = ".gif";
      } else if (/\/jpe?g$/.test(contentType)) {
        extension = ".jpg";
      } else {
        throw "Unsupported image type: "+contentType;
      }
      var name = imagePrefix + imageCounter + extension;
      imageCounter++;
      textElements.push('![image alt text]('+name+')');
      result.images.push( {
        "bytes": element.getChild(i).getBlob().getBytes(), 
        "blob": element.getChild(i).getBlob(), 
        "type": contentType, 
        "name": name});
    } else if (t === DocumentApp.ElementType.PAGE_BREAK) {
      // ignore
    } else if (t === DocumentApp.ElementType.HORIZONTAL_RULE) {
      textElements.push('* * *\n');
    } else if (t === DocumentApp.ElementType.FOOTNOTE) {
      textElements.push(' (NOTE: '+element.getChild(i).getFootnoteContents().getText()+')');
    } else {
      throw "Paragraph "+index+" of type "+element.getType()+" has an unsupported child: "
      +t+" "+(element.getChild(i)["getText"] ? element.getChild(i).getText():'')+" index="+index;
    }
  }

  if (textElements.length==0) {
    // Isn't result empty now?
    return result;
  }
  
  // evb: Add source pretty too. (And abbreviations: src and srcp.)
  // process source code block:
  if (/^\s*---\s+srcp\s*$/.test(pOut) || /^\s*---\s+source pretty\s*$/.test(pOut)) {
    result.sourcePretty = "start";
  } else if (/^\s*---\s+src\s*$/.test(pOut) || /^\s*---\s+source code\s*$/.test(pOut)) {
    result.source = "start";
  } else if (/^\s*---\s+class\s+([^ ]+)\s*$/.test(pOut)) {
    result.inClass = "start";
    result.className = RegExp.$1;
  } else if (/^\s*---\s*$/.test(pOut)) {
    result.source = "end";
    result.sourcePretty = "end";
    result.inClass = "end";
  } else if (/^\s*---\s+jsperf\s*([^ ]+)\s*$/.test(pOut)) {
    result.text = '<iframe style="width: 100%; height: 340px; overflow: hidden; border: 0;" '+
                  'src="http://www.html5rocks.com/static/jsperfview/embed.html?id='+RegExp.$1+
                  '"></iframe>';
  
  //Paragraphs containing any text elements that look like a code block are code block lines
  } else if (anyCBL(settings, textElements, indented)) {
    //If paragraph is not indented, and is a CBL, then remove the leading tab if there
    //is one, since it is there just to indicate a code block.
    if (pOut.length > 1 && pOut.charAt(0) === "\t" && !indented) {
      pOut = pOut.slice(1);
    }
    result.text = pOut;
    result.cbl = true;
    
  //Blank paragraphs following a code block are part of the code block
  } else if (inCodeBlock && pOut.trim().length == 0) {
    result.text = "";
    result.cbl = true;
    
  } else {

    prefix = findPrefix(inSrc, element, listCounters);
  
    var pOut = "";
    
    for (var i=0; i<textElements.length; i++) {
      var txt = textElements[i];

      var processed = processTextElement(inSrc, textElements[i], settings, inCodeBlock);
      pOut += processed;//.markdown;
    }
    
    // replace Unicode quotation marks
    pOut = pOut.replace('\u201d', '"').replace('\u201c', '"');
 
    result.text = prefix+pOut;
  }
  
  return result;
}

function isTextCourier(txt, c) {
  return (txt.getFontFamily(c) == DocumentApp.FontFamily.COURIER_NEW);
}

function anyCBL(settings, txts, indented) {
  for (var i=0; i<txts.length; i++) {
    var txt = txts[i];
    if (isCBL(settings, txt, indented)) return true;
  }
  return false;
}

function isCBL(settings, txt, indented) {
  if (typeof(txt) === 'string') {
    return false;
  }
  
  var cbl = false;

  if (settings.codeBlocks && ((txt.getText().length > 1 && txt.getText().charAt(0) === "\t") || indented)) {
    for (var c = 0; c < txt.getText().length; c++) {
      if (isTextCourier(txt, c)) {
        cbl = true;
      }
    }    
  }
  
  return cbl;
}

// Add correct prefix to list items.
function findPrefix(inSrc, element, listCounters) {
  var prefix="";
  if (!inSrc) {
    if (element.getType()===DocumentApp.ElementType.PARAGRAPH) {
      var paragraphObj = element;
      switch (paragraphObj.getHeading()) {
        // Add a # for each heading level. No break, so we accumulate the right number.
        case DocumentApp.ParagraphHeading.HEADING6: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING5: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING4: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING3: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING2: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING1: prefix+="# ";
        default:
      }
    } else if (element.getType()===DocumentApp.ElementType.LIST_ITEM) {
      var listItem = element;
      var nesting = listItem.getNestingLevel()
      for (var i=0; i<nesting; i++) {
        prefix += "    ";
      }
      var gt = listItem.getGlyphType();
      // Bullet list (<ul>):
      if (gt === DocumentApp.GlyphType.BULLET
          || gt === DocumentApp.GlyphType.HOLLOW_BULLET
          || gt === DocumentApp.GlyphType.SQUARE_BULLET) {
        prefix += "* ";
      } else {
        // Ordered list (<ol>):
        var key = listItem.getListId() + '.' + listItem.getNestingLevel();
        var counter = listCounters[key] || 0;
        counter++;
        listCounters[key] = counter;
        prefix += counter+". ";
      }
    }
  }
  return prefix;
}

//Transfer any leading spaces from inside to end of pre, and trailing spaces from inside to start of post,
//so that formatting symbols are adjacent to the words they apply to, without intervening white space.
function compressInside(sections, blank) {
  while (sections.inside.substring(0, 1) == blank) {
    sections.pre = sections.pre + blank; 
    sections.inside = sections.inside.substring(1);
  }
  while (sections.inside.substring(sections.inside.length - 1) == blank) {
    sections.post = blank + sections.post;
    sections.inside = sections.inside.substring(0, sections.inside.length - 1);
  }
}

//Compress inside using spaces, tabs, carriage returns, newlines and form feeds.
function compressInsideWhitespace(sections) {
  compressInside(sections, " ");
  compressInside(sections, "\t");
  compressInside(sections, "\r");
  compressInside(sections, "\n");
  compressInside(sections, "\f");
}

function makeSections(pOut, off, lastOff) {
  var sections = {
      inside: pOut.substring(off, lastOff),
      pre: pOut.substring(0, off),
      post: pOut.substring(lastOff)
    };
  return sections;
}

function processTextElement(inSrc, txt, settings, inCodeBlock) {

  if (typeof(txt) === 'string') {
    return txt;
  }
  
  var pOut = txt.getText();
  if (! txt.getTextAttributeIndices) {
    return pOut;
  }
  
  //Get the offsets within the text where text formatting runs start
  var attrs=txt.getTextAttributeIndices();
    
  //Previous offset processed, starts at end of text
  var lastOff=pOut.length;

  //Process the text string in formatting runs, backwards
  for (var i=attrs.length-1; i>=0; i--) {
    //Start of formatting run
    var off=attrs[i];
    var url=txt.getLinkUrl(off);

    var sections = makeSections(pOut, off, lastOff);

    //Process URL
    if (url) {  // start of link
      // detect links that are in multiple pieces because of errors on formatting:
      if (i>=1 && attrs[i-1]==off-1 && txt.getLinkUrl(attrs[i-1])===url) {
        i-=1;
        off=attrs[i];
        url=txt.getLinkUrl(off);
        sections = makeSections(pOut, off, lastOff);
      }
      
      pOut = sections.pre + '[' + sections.inside + '](' + url + ')' + sections.post;
      
    //Process font for inline code
    } else if (!inSrc && isTextCourier(txt, off)) {
      // detect fonts that are in multiple pieces because of errors on formatting:
      while (i>=1 && isTextCourier(txt, attrs[i-1])) {
        i-=1;
        off=attrs[i];
      }
      sections = makeSections(pOut, off, lastOff);
      
      //Shrink bold/italic regions to reduce the whitespace they apply to.
      compressInsideWhitespace(sections);

      //If we have shrunk the formatted region to nothing, ignore it
      if (sections.inside.length == 0) {
        pOut = sections.pre + sections.post;
        
      //Apply formatting
      } else {      
        pOut = sections.pre + '`' + sections.inside + '`' + sections.post;      
      }
      
    //Process bold and/or italic. Note that this is only processed if this section is NOT
    //an URL or code.
    } else if (txt.isBold(off) || txt.isItalic(off)) {
      
      //FIXME can we use the same "multiple pieces" code above to prevent errors in runs of the same
      //bold/italic state with redundant attributes in the middle?
      
      var bold = txt.isBold(off);
      var italic = txt.isItalic(off);
      
      // Expand run of formatting backwards, if bold/italic state is the same. Not sure why, but Docs occasionally have
      // redundant formatting, most notably around colons.
      while (i>=1 && (txt.isBold(attrs[i-1]) === bold) && (txt.isItalic(attrs[i-1]) === italic)) {
        i-=1;
        off=attrs[i];
      }
      sections = makeSections(pOut, off, lastOff);
      
      var d1 = d2 = "*";
      
      if (bold) {
        var d1 = d2 = "**"  
        if (italic) {
          d1 = "**_"; d2 = "_**";
        }
      }
      
      //Shrink bold/italic regions to reduce the whitespace they apply to.
      compressInsideWhitespace(sections);
      
      //If we have shrunk the formatted region to nothing, ignore it
      if (sections.inside.length == 0) {
        pOut = sections.pre + sections.post;
        
      //Apply formatting
      } else {      
        pOut = sections.pre + d1 + sections.inside + d2 + sections.post;      
      }
    }
    
    lastOff=off;
  }
  
  //Format any text that starts with bold italic as a quote
  if (settings.boldItalicIsQuote && txt.getText().length > 0 && txt.isBold(0) && txt.isItalic(0)) {
    pOut = "> " + pOut;
  }

  return pOut;
}
