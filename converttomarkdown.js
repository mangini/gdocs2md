/*
gdocs2md
========

A simple Google Apps script to convert a properly formatted Google Drive Document to the markdown (.md) format.

## Usage

### Adding to a document
This script must be added to a document to run it - the document doesn't need to be the one you wish to export:
 1. Tools > Script Editor > New
 2. Select "Blank Project", then paste the code from converttomarkdown.js into it and save.

### Preparing files
Put all documents you wish to convert into category folders within a folder in your docs list, called "DocsToConvertToMarkdown". Each category folder can contain multiple documents. You can use just one category folder, e.g. "default" if you don't want to use categories.

### Running the script
1. Tools > Script Manager
2. Select "convertDefaultFolder()" function.
3. Click Run button.
4. All documents in the folder will be converted to markdown, and resulting files put in a new subfolder called "ExportedMarkdown-TIMESTAMP" where TIMESTAMP is the current ISO GMT timestamp.

### Settings
There are several optional features, convertDefaultFolder() runs with most features enabled, however most other functions take a settings object. The following fields should be set to true to enable the corresponding features:
 * **markdownTables** - Output tables in GitHub-Flavoured Markdown rather than HTML. This also supports bold and italic formatting, and inline code blocks, within table cells.

 * **plainTextOutput** - Output markdown to plaintext files (type "text/plain" with .txt extension),allowing for viewing directly in Google Docs. If this is not specified, files will be have type "text/x-markdown" and .md extension.

 * **boldItalicIsQuote** - Any lines starting with bold+italic formatting will become block quotes in the markdown output.

 * **codeBlocks** - Any lines starting with a tab and then containing at least one courier-new formatted character will be considered as code lines. In addition, any empty or whitespace-only lines following a code line will be considered to be code lines. Runs of code lines will be output with three backticks before and after the run, and with the first tab (if any) removed from each line, to form a standard markdown code block.

### Using different folders
You can call convertFolderByName(folderName, settings) with a different folder name as required

### Miscellaneous
There are also functions for emailing documents, see source for details.

## Interpreted formats
  * Text:
    * paragraphs are separated by two newlines
    * text styled as heading 1, 2, 3, etc is converted to Markdown heading: #, ##, ###, etc
    * text formatted with Courier New is backquoted: ``text``
    * links are converted to MD format: `[anchortext](url)`
  * Lists:
    * Numbered lists are converted correctly, including nested lists
    * bullet lists are converted to "`*`" Markdown format appropriately, including nested lists
  * Images:
    * images are correctly extracted and sent as attachments
  * Blocks:
    * Table of contents is replaced by `[[TOC]]`
    * blocks of text delimited by "--- class whateverclassnameyouwant" and "---" are converted to `<div class="whateverclassnameyouwant"></div>`
    * Source code:
      * **UPDATED**: blocks of text delimited by "--- source code" or "--- src" and "---" are converted to `<pre></pre>`
      * **NEW**: blocks of text delimited by "--- source pretty" or "--- srcp" and "---" are converted to `<pre class="prettyprint"></pre>`
    * Tables:
      * **NEW**: Simple `<table>` processing
  * "--- jsperf `<testID>`" is replaced by an iframe that shows an interactive chart of a JSPerf test. The `<testID>` is the last part of the URL of the Browserscope anchor in your JSPerf test. Something like `"agt1YS1wcm9maWxlcnINCxIEVGVzdBjlm_EQDA"` in the URL `http://www.browserscope.org/user/tests/table/agt1YS1wcm9maWxlcnINCxIEVGVzdBjlm_EQDA`

## CONTRIBUTORS

* Renato Mangini - [G+](//google.com/+renatomangini) - [Github](//github.com/mangini)
* Ed Bacher - [G+](//plus.google.com/106923847899206957842) - [Github](//github.com/evbacher)
* Ben Webster - [Github](//github.com/trepidacious)

## LICENSE

Use this script at your will, on any document you want and for any purpose, commercial or not.
The MarkDown files generated by this script are not considered derivative work and
don't require any attribution to the owners of this script.

If you want to modify and redistribute the script (not the converted documents - those are yours),
just keep a reference to this repo or to the license info below:

```
Copyright 2013 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```
*/

function convertDefaultFolder() {
  var settings = {markdownTables: true, plainTextOutput: false, boldItalicIsQuote: true, codeBlocks: true, codeBlockMinIndent: 12};
  convertDefaultFolderWithSettings(settings);
}

function convertDefaultFolderWithSettings(settings) {
  convertDownOneLevelByName('DocsToConvertToMarkdown', settings);
}

function convertDownOneLevelByName(folderName, settings) {
  var folderIt = DriveApp.getFoldersByName(folderName);
  if (folderIt.hasNext()) {
    var folder = folderIt.next();
    convertDownOneLevel(folder, settings);
  }
}

function convertDownOneLevel(rootFolder, settings) {

  var mainExportFolder = rootFolder.createFolder(exportFolderName())
  var folders = rootFolder.getFolders();
  //Convert all folders that don't start with our export prefix
  while (folders.hasNext()) {
    var folder = folders.next();
    if (folder.getName().substring(0, exportFolderPrefix.length) != exportFolderPrefix) {
      var exportFolder = mainExportFolder.createFolder(folder.getName())
      convertFolder(folder, exportFolder, settings);
    }
  }
  //Convert contents of the folder as well, mainly to catch any meta data
  convertFolder(rootFolder, mainExportFolder, settings);
}

function convertFolderByName(folderName, settings) {
  var folderIt = DriveApp.getFoldersByName(folderName);
  if (folderIt.hasNext()) {
    var folder = folderIt.next();
    var exportFolder = folder.createFolder(exportFolderName())
    convertFolder(folder, exportFolder, settings);
  }
}

function convertFolder(folder, exportFolder, settings) {
  var files = folder.getFilesByType(MimeType.GOOGLE_DOCS);

  var convertedDocNames = "";

  while (files.hasNext()) {
    var file = files.next();
    var doc = DocumentApp.openById(file.getId());
    var converted = convertToMarkdownAttachments(doc, settings);
    var docFolder = exportFolder.createFolder(doc.getName());
    convertedDocNames += doc.getName() + "\n";

    // Write all files to target folder
    for(var file in converted.files) {
      file = converted.files[file];
      var blob = file.blob.copyBlob();
      var name = file.name;
      blob.setName(name);
      docFolder.createFile(blob);
    }

    // Write markdown file to target folder
    if (settings.plainTextOutput) {
      docFolder.createFile(doc.getName() + ".txt", converted.markdown, "text/plain");
    } else {
      docFolder.createFile(doc.getName() + ".md", converted.markdown, "text/x-markdown");
    }
  }

  //FIXME display some other way? Browser only works from a spreadsheet!
  //Browser.msgBox("Export complete", "Converted documents:\n" + convertedDocNames, Browser.Buttons.OK)
}

var exportFolderPrefix = "ExportedMarkdown-";

function exportFolderName() {
  var timeStamp = Utilities.formatDate(new Date(), "GMT", "yyyy-MM-dd'T'HH:mm:ss'Z'");
  return exportFolderPrefix + timeStamp;
}

function mailActiveDocumentAsMarkdown() {
  var doc = DocumentApp.getActiveDocument();
  var attachments = convertToMarkdownAttachments(doc).attachments;
  mailWithAttachments(doc, attachments);
}

function mailWithAttachments(document, attachments) {
  MailApp.sendEmail(
    Session.getActiveUser().getEmail(),
    "[MARKDOWN_MAKER] "+document.getName(),
    "Your converted markdown document is attached (converted from " + document.getUrl() + ")" +
    "\n\nDon't know how to use the format options? See http://github.com/mangini/gdocs2md\n",
    { "attachments": attachments });
}

function convertToMarkdownAttachments(document, settings) {
  var numChildren = document.getActiveSection().getNumChildren();
  var text = "";
  var inSrc = false;
  var inCodeBlock = false;
  var inClass = false;
  var globalImageCounter = 0;
  var globalListCounters = {};
  // edbacher: added a variable for indent in src <pre> block. Let style sheet do margin.
  var srcIndent = "";

  var attachments = [];
  var files = [];

  // Walk through all the child elements of the doc.
  for (var i = 0; i < numChildren; i++) {
    var child = document.getActiveSection().getChild(i);
    var result = processParagraph(i, child, inSrc, globalImageCounter, globalListCounters, settings, inCodeBlock);
    globalImageCounter += (result && result.images) ? result.images.length : 0;
    if (result!==null) {

      if (inCodeBlock && !result.cbl) {
        text+="```\n\n";
        inCodeBlock = false;
      }

      if (result.cbl) {
        if (!inCodeBlock) {
          text+="\n```\n";
          inCodeBlock = true;
        }
        text+=result.text + "\n";

      } else if (result.sourcePretty==="start" && !inSrc) {
        inSrc=true;
        text+="<pre class=\"prettyprint\">\n";
      } else if (result.sourcePretty==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.source==="start" && !inSrc) {
        inSrc=true;
        text+="<pre>\n";
      } else if (result.source==="end" && inSrc) {
        inSrc=false;
        text+="</pre>\n\n";
      } else if (result.inClass==="start" && !inClass) {
        inClass=true;
        text+="<div class=\""+result.className+"\">\n";
      } else if (result.inClass==="end" && inClass) {
        inClass=false;
        text+="</div>\n\n";
      } else if (inClass) {
        text+=result.text+"\n\n";
      } else if (inSrc) {
        text+=(srcIndent+escapeHTML(result.text)+"\n");
      } else if (result.text && result.text.length>0) {
        text+=result.text+"\n\n";
      }

      if (result.images && result.images.length>0) {
        for (var j=0; j<result.images.length; j++) {
          attachments.push( {
            "fileName": result.images[j].name,
            "mimeType": result.images[j].type,
            "content": result.images[j].bytes } );

          files.push( {
            "name" : result.images[j].name,
            "blob" : result.images[j].blob
          });

        }
      }
    } else if (inSrc) { // support empty lines inside source code
      text+='\n';
    }

  }

  if (settings.plainTextOutput) {
    attachments.push({"fileName":document.getName()+".txt", "mimeType": "text/plain", "content": text});
  } else {
    attachments.push({"fileName":document.getName()+".md", "mimeType": "text/x-markdown", "content": text});
  }

  return {attachments: attachments, files: files, markdown: text};
}

function escapeHTML(text) {
  return text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

// Process each child element (not just paragraphs).
function processParagraph(index, element, inSrc, imageCounter, listCounters, settings, inCodeBlock) {

  // Set up for real results.
  var result = {};
  var pOut = "";
  var textElements = [];
  var imagePrefix = "image_";
  var indented = false;

  // First, check for things that require no processing.
  if (element.getNumChildren()==0) {
    if (inCodeBlock) {
      result.text = "";
      result.cbl = true;
      return result;
    } else {
      return null;
    }
  }

  // Punt on TOC.
  if (element.getType() === DocumentApp.ElementType.TABLE_OF_CONTENTS) {
    return {"text": "[[TOC]]"};
  }

  //Check for indent that can indicate code block etc.
  if (element.getType() === DocumentApp.ElementType.PARAGRAPH) {
    if (isNumber(settings.codeBlockMinIndent)) {
      if (element.getIndentStart() > settings.codeBlockMinIndent) {
        indented = true;
      }
    }
  }

  // Handle Table elements. Pretty simple-minded now, but works for simple tables.
  // Note that Markdown does not process within block-level HTML, so it probably
  // doesn't make sense to add markup within tables.
  if (element.getType() === DocumentApp.ElementType.TABLE) {

    //Markdown table
    if (settings.markdownTables) {
      textElements.push("\n");
      var nCols = element.getChild(0).getNumCells();
      for (var i = 0; i < element.getNumChildren(); i++) {
        // process this row
        for (var j = 0; j < nCols; j++) {
          var cell = element.getChild(i).getChild(j);

          //We expect the TableCell to have a single Paragraph child - if
          //so we will add all its text elements to our textElements array for
          //later processing
          if (cell.getNumChildren() > 0) {
            var cellPara = cell.getChild(0);
            if (cellPara.getType() === DocumentApp.ElementType.PARAGRAPH) {
              for (var k = 0; k < cellPara.getNumChildren(); k++) {
                var el = cellPara.getChild(k);
                if (el.getType() === DocumentApp.ElementType.TEXT) {
                  textElements.push(el);
                }
              }
            }
          }

          if (j < nCols - 1) textElements.push(" | ");
        }
        textElements.push("\n");

        //Line of row separators after first row (assumed to be table headings)
        if (i == 0) {
          for (var j = 0; j < nCols; j++) {
            textElements.push("---");
            if (j < nCols - 1) textElements.push(" | ");
          }
          textElements.push("\n");
        }
      }
      textElements.push("\n");

    //HTML table
    } else {
      textElements.push("<table>\n");
      var nCols = element.getChild(0).getNumCells();
      for (var i = 0; i < element.getNumChildren(); i++) {
        textElements.push("  <tr>\n");
        // process this row
        for (var j = 0; j < nCols; j++) {
          textElements.push("    <td>" + element.getChild(i).getChild(j).getText() + "</td>\n");
        }
        textElements.push("  </tr>\n");
      }
      textElements.push("</table>\n");
    }
  }

  // Process various types (ElementType).
  for (var i = 0; i < element.getNumChildren(); i++) {
    var t=element.getChild(i).getType();

    if (t === DocumentApp.ElementType.TABLE_ROW) {
      // do nothing: already handled TABLE_ROW
    } else if (t === DocumentApp.ElementType.TEXT) {
      var txt=element.getChild(i);
      pOut += txt.getText();
      textElements.push(txt);
    } else if (t === DocumentApp.ElementType.INLINE_IMAGE) {
      result.images = result.images || [];
      var contentType = element.getChild(i).getBlob().getContentType();
      var extension = "";
      if (/\/png$/.test(contentType)) {
        extension = ".png";
      } else if (/\/gif$/.test(contentType)) {
        extension = ".gif";
      } else if (/\/jpe?g$/.test(contentType)) {
        extension = ".jpg";
      } else {
        throw "Unsupported image type: "+contentType;
      }
      var name = imagePrefix + imageCounter + extension;
      imageCounter++;
      textElements.push('![image alt text]('+name+')');
      result.images.push( {
        "bytes": element.getChild(i).getBlob().getBytes(),
        "blob": element.getChild(i).getBlob(),
        "type": contentType,
        "name": name});
    } else if (t === DocumentApp.ElementType.PAGE_BREAK) {
      // ignore
    } else if (t === DocumentApp.ElementType.HORIZONTAL_RULE) {
      textElements.push('* * *\n');
    } else if (t === DocumentApp.ElementType.FOOTNOTE) {
      textElements.push(' (NOTE: '+element.getChild(i).getFootnoteContents().getText()+')');
    } else {
      throw "Paragraph "+index+" of type "+element.getType()+" has an unsupported child: "
      +t+" "+(element.getChild(i)["getText"] ? element.getChild(i).getText():'')+" index="+index;
    }
  }

  if (textElements.length==0) {
    // Isn't result empty now?
    return result;
  }

  // evb: Add source pretty too. (And abbreviations: src and srcp.)
  // process source code block:
  if (/^\s*---\s+srcp\s*$/.test(pOut) || /^\s*---\s+source pretty\s*$/.test(pOut)) {
    result.sourcePretty = "start";
  } else if (/^\s*---\s+src\s*$/.test(pOut) || /^\s*---\s+source code\s*$/.test(pOut)) {
    result.source = "start";
  } else if (/^\s*---\s+class\s+([^ ]+)\s*$/.test(pOut)) {
    result.inClass = "start";
    result.className = RegExp.$1;
  } else if (/^\s*---\s*$/.test(pOut)) {
    result.source = "end";
    result.sourcePretty = "end";
    result.inClass = "end";
  } else if (/^\s*---\s+jsperf\s*([^ ]+)\s*$/.test(pOut)) {
    result.text = '<iframe style="width: 100%; height: 340px; overflow: hidden; border: 0;" '+
                  'src="http://www.html5rocks.com/static/jsperfview/embed.html?id='+RegExp.$1+
                  '"></iframe>';

  //Paragraphs containing any text elements that look like a code block are code block lines
  } else if (anyCBL(settings, textElements, indented)) {
    //If paragraph is not indented, and is a CBL, then remove the leading tab if there
    //is one, since it is there just to indicate a code block.
    if (pOut.length > 1 && pOut.charAt(0) === "\t" && !indented) {
      pOut = pOut.slice(1);
    }
    result.text = pOut;
    result.cbl = true;

  //Blank paragraphs following a code block are part of the code block
  } else if (inCodeBlock && pOut.trim().length == 0) {
    result.text = "";
    result.cbl = true;

  } else {

    prefix = findPrefix(inSrc, element, listCounters);

    var pOut = "";

    for (var i=0; i<textElements.length; i++) {
      var txt = textElements[i];

      var processed = processTextElement(inSrc, textElements[i], settings, inCodeBlock);
      pOut += processed;//.markdown;
    }

    // replace Unicode quotation marks
    pOut = pOut.replace('\u201d', '"').replace('\u201c', '"');

    result.text = prefix+pOut;
  }

  return result;
}

function isTextCourier(txt, c) {
  return (txt.getFontFamily(c) == DocumentApp.FontFamily.COURIER_NEW);
}

function anyCBL(settings, txts, indented) {
  for (var i=0; i<txts.length; i++) {
    var txt = txts[i];
    if (isCBL(settings, txt, indented)) return true;
  }
  return false;
}

function isCBL(settings, txt, indented) {
  if (typeof(txt) === 'string') {
    return false;
  }

  var cbl = false;

  if (settings.codeBlocks && ((txt.getText().length > 1 && txt.getText().charAt(0) === "\t") || indented)) {
    for (var c = 0; c < txt.getText().length; c++) {
      if (isTextCourier(txt, c)) {
        cbl = true;
      }
    }
  }

  return cbl;
}

// Add correct prefix to list items.
function findPrefix(inSrc, element, listCounters) {
  var prefix="";
  if (!inSrc) {
    if (element.getType()===DocumentApp.ElementType.PARAGRAPH) {
      var paragraphObj = element;
      switch (paragraphObj.getHeading()) {
        // Add a # for each heading level. No break, so we accumulate the right number.
        case DocumentApp.ParagraphHeading.HEADING6: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING5: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING4: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING3: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING2: prefix+="#";
        case DocumentApp.ParagraphHeading.HEADING1: prefix+="# ";
        default:
      }
    } else if (element.getType()===DocumentApp.ElementType.LIST_ITEM) {
      var listItem = element;
      var nesting = listItem.getNestingLevel()
      for (var i=0; i<nesting; i++) {
        prefix += "    ";
      }
      var gt = listItem.getGlyphType();
      // Bullet list (<ul>):
      if (gt === DocumentApp.GlyphType.BULLET
          || gt === DocumentApp.GlyphType.HOLLOW_BULLET
          || gt === DocumentApp.GlyphType.SQUARE_BULLET) {
        prefix += "* ";
      } else {
        // Ordered list (<ol>):
        var key = listItem.getListId() + '.' + listItem.getNestingLevel();
        var counter = listCounters[key] || 0;
        counter++;
        listCounters[key] = counter;
        prefix += counter+". ";
      }
    }
  }
  return prefix;
}

//Transfer any leading spaces from inside to end of pre, and trailing spaces from inside to start of post,
//so that formatting symbols are adjacent to the words they apply to, without intervening white space.
function compressInside(sections, blank) {
  while (sections.inside.substring(0, 1) == blank) {
    sections.pre = sections.pre + blank;
    sections.inside = sections.inside.substring(1);
  }
  while (sections.inside.substring(sections.inside.length - 1) == blank) {
    sections.post = blank + sections.post;
    sections.inside = sections.inside.substring(0, sections.inside.length - 1);
  }
}

//Compress inside using spaces, tabs, carriage returns, newlines and form feeds.
function compressInsideWhitespace(sections) {
  compressInside(sections, " ");
  compressInside(sections, "\t");
  compressInside(sections, "\r");
  compressInside(sections, "\n");
  compressInside(sections, "\f");
}

function makeSections(pOut, off, lastOff) {
  var sections = {
      inside: pOut.substring(off, lastOff),
      pre: pOut.substring(0, off),
      post: pOut.substring(lastOff)
    };
  return sections;
}

function processTextElement(inSrc, txt, settings, inCodeBlock) {

  if (typeof(txt) === 'string') {
    return txt;
  }

  var pOut = txt.getText();
  if (! txt.getTextAttributeIndices) {
    return pOut;
  }

  //Get the offsets within the text where text formatting runs start
  var attrs=txt.getTextAttributeIndices();

  //Previous offset processed, starts at end of text
  var lastOff=pOut.length;

  //Process the text string in formatting runs, backwards
  for (var i=attrs.length-1; i>=0; i--) {
    //Start of formatting run
    var off=attrs[i];
    var url=txt.getLinkUrl(off);

    var sections = makeSections(pOut, off, lastOff);

    //Process URL
    if (url) {  // start of link
      // detect links that are in multiple pieces because of errors on formatting:
      if (i>=1 && attrs[i-1]==off-1 && txt.getLinkUrl(attrs[i-1])===url) {
        i-=1;
        off=attrs[i];
        url=txt.getLinkUrl(off);
        sections = makeSections(pOut, off, lastOff);
      }

      pOut = sections.pre + '[' + sections.inside + '](' + url + ')' + sections.post;

    //Process font for inline code
    } else if (!inSrc && isTextCourier(txt, off)) {
      // detect fonts that are in multiple pieces because of errors on formatting:
      while (i>=1 && isTextCourier(txt, attrs[i-1])) {
        i-=1;
        off=attrs[i];
      }
      sections = makeSections(pOut, off, lastOff);

      //Shrink bold/italic regions to reduce the whitespace they apply to.
      compressInsideWhitespace(sections);

      //If we have shrunk the formatted region to nothing, ignore it
      if (sections.inside.length == 0) {
        pOut = sections.pre + sections.post;

      //Apply formatting
      } else {
        pOut = sections.pre + '`' + sections.inside + '`' + sections.post;
      }

    //Process bold and/or italic. Note that this is only processed if this section is NOT
    //an URL or code.
    } else if (txt.isBold(off) || txt.isItalic(off)) {

      //FIXME can we use the same "multiple pieces" code above to prevent errors in runs of the same
      //bold/italic state with redundant attributes in the middle?

      var bold = txt.isBold(off);
      var italic = txt.isItalic(off);

      // Expand run of formatting backwards, if bold/italic state is the same. Not sure why, but Docs occasionally have
      // redundant formatting, most notably around colons.
      while (i>=1 && (txt.isBold(attrs[i-1]) === bold) && (txt.isItalic(attrs[i-1]) === italic)) {
        i-=1;
        off=attrs[i];
      }
      sections = makeSections(pOut, off, lastOff);

      var d1 = d2 = "*";

      if (bold) {
        var d1 = d2 = "**"
        if (italic) {
          d1 = "**_"; d2 = "_**";
        }
      }

      //Shrink bold/italic regions to reduce the whitespace they apply to.
      compressInsideWhitespace(sections);

      //If we have shrunk the formatted region to nothing, ignore it
      if (sections.inside.length == 0) {
        pOut = sections.pre + sections.post;

      //Apply formatting
      } else {
        pOut = sections.pre + d1 + sections.inside + d2 + sections.post;
      }
    }

    lastOff=off;
  }

  //Format any text that starts with bold italic as a quote
  if (settings.boldItalicIsQuote && txt.getText().length > 0 && txt.isBold(0) && txt.isItalic(0)) {
    pOut = "> " + pOut;
  }

  return pOut;
}
